import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SVG_DIR = path.join(__dirname, '../src/icons/svg');
const ICONS_DIR = path.join(__dirname, '../src/icons/generated');
const INDEX_FILE = path.join(__dirname, '../src/icons/generated/index.ts');

/**
 * Parse SVG content into icon definition structure
 * @param {string} svgContent - Raw SVG file content
 * @returns {Object|null} Parsed icon definition
 */
function parseSVG(svgContent) {
  const viewBoxMatch = svgContent.match(/viewBox="([^"]+)"/);
  const viewBox = viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';

  const innerMatch = svgContent.match(/<svg[^>]*>([\s\S]*)<\/svg>/);
  if (!innerMatch) return null;

  const inner = innerMatch[1].trim();

  const elements = [];
  const elementRegex = /<(\w+)([^>]*)(?:\/>|>([\s\S]*?)<\/\1>)/g;
  let match;

  while ((match = elementRegex.exec(inner)) !== null) {
    const tag = match[1];
    const attrsString = match[2];
    const children = match[3];

    const attrs = {};
    const attrRegex = /(\w+(?:-\w+)?)="([^"]*)"/g;
    let attrMatch;
    while ((attrMatch = attrRegex.exec(attrsString)) !== null) {
      let key = attrMatch[1];
      if (key.includes('-')) {
        key = key.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
      }
      attrs[key] = attrMatch[2];
    }

    const element = { tag, attrs };
    if (children && children.trim()) {
      element.children = [];
    }

    elements.push(element);
  }

  return {
    viewBox,
    content: elements,
  };
}

/**
 * Convert kebab-case to camelCase, handling names that start with numbers
 * @param {string} str - Kebab-case string
 * @returns {string} CamelCase string
 */
function toCamelCase(str) {
  // First, sanitize the filename by replacing problematic characters
  str = str
    .replace(/[^a-zA-Z0-9\-_\s]/g, '') // Remove special characters except hyphens, underscores, and spaces
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/_/g, '-') // Replace underscores with hyphens
    .toLowerCase();

  // If starts with number, prefix with 'icon'
  if (/^\d/.test(str)) {
    str = 'icon' + str.charAt(0).toUpperCase() + str.slice(1);
  }

  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Convert kebab-case to PascalCase
 * @param {string} str - Kebab-case string
 * @returns {string} PascalCase string
 */
function toPascalCase(str) {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

/**
 * Generate individual icon files and index
 */
function generateIconsFiles() {
  if (!fs.existsSync(ICONS_DIR)) {
    fs.mkdirSync(ICONS_DIR, { recursive: true });
  }

  const svgFiles = fs.readdirSync(SVG_DIR).filter(file => file.endsWith('.svg'));
  const iconExports = [];
  const iconMap = [];

  for (const file of svgFiles) {
    const name = path.basename(file, '.svg');
    const camelName = toCamelCase(name);
    const pascalName = toPascalCase(name);
    const svgContent = fs.readFileSync(path.join(SVG_DIR, file), 'utf-8');

    const parsed = parseSVG(svgContent);
    if (!parsed) continue;

    const iconDefinition = {
      name: camelName,
      viewBox: parsed.viewBox,
      content: parsed.content,
    };

    const iconFileContent = `import { IconDefinition } from '../../types';

/**
 * ${pascalName} icon definition
 */
export const ${camelName}: IconDefinition = ${JSON.stringify(iconDefinition, null, 2)};
`;

    fs.writeFileSync(path.join(ICONS_DIR, `${camelName}.ts`), iconFileContent);

    iconExports.push(`export { ${camelName} } from './${camelName}';`);
    iconMap.push(
      `  '${camelName}': lazy(() => import('./${camelName}').then(m => ({ default: m.${camelName} })))`
    );
  }

  const indexContent = `/**
 * Auto-generated icon exports
 * @generated by scripts/build-icons.js
 */

/**
 * Lazy loading helper for dynamic icon imports
 */
function lazy<T>(loader: () => Promise<{ default: T }>): () => Promise<T> {
  let promise: Promise<T> | null = null;
  return () => {
    if (!promise) {
      promise = loader().then(m => m.default);
    }
    return promise;
  };
}

${iconExports.join('\n')}

/**
 * Lazy-loaded icon map for dynamic imports
 */
export const iconMap: Record<string, () => Promise<any>> = {
${iconMap.join(',\n')}
};

/**
 * Get icon names list
 */
export const iconNames = [
${svgFiles.map(f => `  '${toCamelCase(path.basename(f, '.svg'))}'`).join(',\n')}
] as const;

export type IconName = typeof iconNames[number];
`;

  fs.writeFileSync(INDEX_FILE, indexContent);

  console.log(`âœ… Generated ${svgFiles.length} icon files in ${ICONS_DIR}`);
  console.log(`ðŸ“¦ Icons are split into individual files for optimal bundling`);
}

/**
 * Create lazy loading helper
 */
function createLazyHelper() {
  const helperContent = `/**
 * Lazy loading helper for dynamic icon imports
 */
export function lazy<T>(loader: () => Promise<{ default: T }>): () => Promise<T> {
  let promise: Promise<T> | null = null;
  return () => {
    if (!promise) {
      promise = loader().then(m => m.default);
    }
    return promise;
  };
}
`;

  const indexPath = path.join(ICONS_DIR, 'index.ts');
  const currentContent = fs.existsSync(indexPath) ? fs.readFileSync(indexPath, 'utf-8') : '';

  if (!currentContent.includes('function lazy')) {
    const updatedContent = `${helperContent}\n${currentContent}`;
    fs.writeFileSync(indexPath, updatedContent);
  }
}

generateIconsFiles();
